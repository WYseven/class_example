<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title></title>
		<style>
			
		</style>
		<script src="../../vue.js"></script>
	</head>

	<body>
		<div id="demo">
			<!-- 在这里写逻辑，难以维护 -->
			
			<p>message：{{ message.split("").reverse().join("") }}</p>
			
			<h3>测试多次使用computed计算属性</h3>
			<hr>
			<p>message2：{{ reverseMessage2 }}</p>
			<p>message2：{{ reverseMessage2 }}</p>
			<p>message2：{{ reverseMessage2 }}</p>

			<h3>测试多次使用methods计算属性</h3>
			<hr>
			<p>message3：{{ reverseMessage3() }}</p>
			<p>message3：{{ reverseMessage3() }}</p>
			<p>message3：{{ reverseMessage3() }}</p>
		</div>

		<script>
			/*
				在模板中放入表达式非常便利，模板是为了描述视图的结构。
				但是在模板中放入太多逻辑，使得模板过重难以维护。

				把复杂的逻辑放在计算属性中
					也就是选项参数的computed属性中

				除了计算属性可以达到模板与逻辑分离，methods也可以实现

				有明显的的区别：
					计算缓存基于它依赖的数据，计算属性只有在它所依赖的数据发生改变改回重新执行得
					到值
					如果数据不发生改变，多次访问计算属性，只会返回之前计算后的值，不会调用函数

					使用methods总会调用函数

					在计算大量的数据的时候，建议使用计算属性
					不希望有缓存，则使用methods

			*/
			var vm = new Vue({
				el:"#demo",
				data:{
					message:"hello,Vue",
					message2:"hello,Vue",
					message3:"hello,Vue"
				},
				computed:{
					reverseMessage2:function (){
						console.log("reverseMessage2");
						return this.message2.split("").reverse().join("")	
					}
				},
				methods:{
					reverseMessage3:function (){
						console.log("我被调用了");
						return this.message3.split("").reverse().join("")	
					}
				}
			});

			/*vm.message3 = "测试methods";

			vm.message2 = "测试computed"*/

		</script>
	</body>
</html>